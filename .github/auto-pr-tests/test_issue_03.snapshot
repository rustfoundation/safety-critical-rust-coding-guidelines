=====CONTENT=====

.. guideline:: Integer shift shall only be performed through `checked_` APIs
    :id: gui_Utmyz6mWEfiC
    :category: mandatory
    :status: draft
    :release: 1.7.0-latest
    :fls: fls_sru4wi5jomoe
    :decidability: decidable
    :scope: module
    :tags: numerics, reduce-human-error, maintainability, portability, surprising-behavior

    In particular, the user should only perform left shifts via the `checked_shl <https://doc.rust-lang.org/core/index.html?search=%22checked_shl%22>`__ function and right shifts via the `checked_shr <https://doc.rust-lang.org/core/index.html?search=%22checked_shr%22>`__ function. Both of these functions exist in `core <https://doc.rust-lang.org/core/index.html>`__.

    This rule applies to the following primitive types:

    -  ``i8``
    -  ``i16``
    -  ``i32``
    -  ``i64``
    -  ``i128``
    -  ``u8``
    -  ``u16``
    -  ``u32``
    -  ``u64``
    -  ``u128``
    -  ``usize``
    -  ``isize``

    .. rationale::
        :id: rat_QYov4YymiNrs
        :status: draft

        This is directly inspired by `INT34-C. Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand <https://wiki.sei.cmu.edu/confluence/display/c/INT34-C.+Do+not+shift+an+expression+by+a+negative+number+of+bits+or+by+greater+than+or+equal+to+the+number+of+bits+that+exist+in+the+operand>`__.

        In Rust these out-of-range shifts don’t give rise to Undefined Behavior; however, they are still problematic in Safety Critical contexts for two reasons.

        **Reason 1: inconsistent behavior**

        The behavior of shift operations depends on the compilation mode. Say for example, that we have a number ``x`` of type ``uN``, and we perform the operation

        ``x << M``

        Then, it will behave like this:

        +----------------------+-----------------+-----------------------+-----------------------+
        | **Compilation Mode** | ``0 <= M < N``  | ``M < 0``             | ``N <= M``            |
        +======================+=================+=======================+=======================+
        | Debug                | Shifts normally | Panics                | Panics                |
        +----------------------+-----------------+-----------------------+-----------------------+
        | Release              | Shifts normally | Shifts by ``M mod N`` | Shifts by ``M mod N`` |
        +----------------------+-----------------+-----------------------+-----------------------+

        ..

        Note: the behavior is exactly the same for the ``>>`` operator.

        Panicking in ``Debug`` is an issue by itself, however, a perhaps larger issue there is that its behavior is different from that of ``Release``. Such inconsistencies aren’t acceptable in Safety Critical scenarios.

        Therefore, a consistently-behaved operation should be required for performing shifts.

        Reason 2: programmer intent
        ---------------------------

        There is no scenario in which it makes sense to perform a shift of negative length, or of more than ``N - 1`` bits. The operation itself becomes meaningless.

        Therefore, an API that restricts the length of the shift to the range ``[0, N - 1]`` should be used instead of the ``<<`` and ``>>`` operators.

        The Solution
        ------------

        The ideal solution for this exists in ``core``: ``checked_shl`` and ``checked_shr``.

        ``<T>::checked_shl(M)`` returns a value of type ``Option<T>``, in the following way:

        -  If ``M < 0``, the output is ``None``
        -  If ``0 <= M < N`` for ``T`` of ``N`` bits, then the output is ``Some(T)``
        -  If ``N <= M``, the output is ``None``

        This API has consistent behavior across ``Debug`` and ``Release``, and makes the programmer intent explicit, which effectively solves this issue.

    .. non_compliant_example::
        :id: non_compl_ex_u6gKzSi0Tgi5
        :status: draft

        As seen below in the ``non_compliant_example()`` function:

        -  the use of ``<<`` will exhibit different behavior between debug and release builds,
        -  and will panic if the shift amount is negative or greater than or equal to the number of bits.

        .. rust-example::

            fn non_compliant_example() {
                let x: u32 = 1;
                let shift_amount: u32 = 32; // This is >= the number of bits in u32

                // This will panic in debug mode, or wrap in release mode
                let result = x << shift_amount;
                println!("Result: {}", result);
            }


    .. compliant_example::
        :id: compl_ex_Wawza8cZqixM
        :status: draft

        As seen below in the ``compliant_example()`` function:

        -  the use of ``checked_shl`` will exhibit consistent behavior between debug and release builds,
        -  and will return ``None`` if the shift amount is negative or greater than or equal to the number of bits.

        .. rust-example::

            fn compliant_example() {
                let x: u32 = 1;
                let shift_amount: u32 = 32; // This is >= the number of bits in u32

                // This will return None instead of panicking or wrapping
                match x.checked_shl(shift_amount) {
                    Some(result) => println!("Result: {}", result),
                    None => println!("Shift amount is out of range"),
                }
            }


=====CONTENT=END=====
